const db = require('./database.js')

/** Class representing a Phishmonger email template */
class Template{
  /**
  * @param {string} title - The name of the template. A simple name for this phishing scenario.
  * @param {number} ich_id - The ID of the user who published the scenario. This is infered from the user's API key.
  * @param {string} short_description - A layman's description of the scenario/template for quick searches.
  * @param {string} report_description - Boilerplate description of the scenario in professional writing to help automate reporting.
  * @param {string} mime_content - The template itself. This is the SMTP DATA of the email, as captured and modified by Phishmonger.
  * @param {string} specimen - A base64 encoded screenshot of the scenario, as generated by Phishmonger's preview feature. 
  * @returns {number} new_template_id - The ID of the template returned from the DB.
  */
  constructor(ich_id, title, short_description, report_description, mime_content, image){
    let new_template_id = Template.AddTemplate(ich_id, title, short_description, report_description, mime_content).lastInsertRowid
    let specimen_id = new Specimen(new_template_id, ich_id, image)
    return new_template_id
  }
  /**
  * @param {object} filter - A JSON key:value pair hash of search filters we would like to apply to our search. Blank/undefined/null will return all templates.
  * @param {number} limit - The number of search results to return. Useful for pagination.
  * @param {number} offset - The number of search results to skip. Useful for pagination.
  */
  static ListTemplates(filter, limit, offset){
    let list_templates = db.prepare(`
      SELECT template_id, ich_id, created_at, title, short_description, specimen_id FROM templates WHERE
        ich_id LIKE $ich_id AND
        title LIKE $title AND
        short_description LIKE $short_description
        LIMIT $limit OFFSET $offset
    `)
    return list_templates.all({
      "ich_id": `%${filter.ich_id}%`,
      "title": `%${filter.title}%`,
      "short_description": `%${filter.short_description}%`,
      "limit": limit,
      "offset": offset
    })
  }
  /**
  * @param {number} tempate_id - The ID for the template that we want to retrieve.
  */
  static GetTemplate(template_id){
    let get_template = db.prepare(`
      SELECT * FROM templates WHERE template_id = $template_id
    `)
    return get_template.get({
      "template_id": template_id
    })
  }
  /**
  * @param {string} title - The name of the template. A simple name for this phishing scenario.
  * @param {number} ich_id - The ID of the user who published the scenario. This is infered from the user's API key.
  * @param {string} short_description - A layman's description of the scenario/template for quick searches.
  * @param {string} report_description - Boilerplate description of the scenario in professional writing to help automate reporting.
  * @param {string} mime_content - The template itself. This is the SMTP DATA of the email, as captured and modified by Phishmonger.
  * @param {number} specimen_id - The ID of the screenshot of the scenario. We keep IDs instead of full images to speed up API calls. API clients can render specimens as needed.
  */
  static AddTemplate(ich_id, title, short_description, report_description, mime_content, specimen_id){
    let add_template = db.prepare(`
      INSERT INTO templates VALUES(
        $template_id,
        $ich_id,
        $created_at,
        $title,
        $short_description,
        $report_description,
        $mime_content
      )
    `)
    return add_template.run({
      "template_id": null,
      "ich_id": ich_id,
      "created_at": Date.now(),
      "title": title,
      "short_description": short_description,
      "report_description": report_description,
      "mime_content": mime_content,
    })
  }
  /**
  * @param {number} template_id - The ID of the template object we are updating.
  * @param {string} title - The name of the template. A simple name for this phishing scenario.
  * @param {string} short_description - A layman's description of the scenario/template for quick searches.
  * @param {string} report_description - Boilerplate description of the scenario in professional writing to help automate reporting.
  * @param {string} mime_content - The template itself. This is the SMTP DATA of the email, as captured and modified by Phishmonger.
  * @param {string} specimen - A base64 encoded screenshot of the scenario, as generated by Phishmonger's preview feature. 
  */
  static UpdateTemplate(template_id, title, short_description, report_description, mime_content, specimen){
  }
  /**
  * @param {number} template_id - The ID of the template object we are deleting.
  */
  static DeleteTemplate(template_id){
  }
}

/** Class representing the results of a phishing campaign that was build from a Phish Market template. Reported by the Phishmonger user and designed to add template metrics for technicians. */
class Scorecard{
  /**
  * @param {number} template_id - The ID of the template the phishing email was build from.
  * @param {number} ich_id - The ID of the user who is submitting the Scorecard. This is infered from the user's API key.
  * @param {(number|string)} spam_filter_id - The spam filter that the technician sent the phishing email to/through. If an number, then it is the ID of an existing SpamFilter object. If a string, we add a new SpamFilter to track.
  * @param {boolean} whitelisted - Did the technician need the client to whitelist this email phishing template? 0 for NO, 1 for YES.
  * @param {number} stars - How did the technician rate the scenario on a scale of 1 to 5? Helps to rank templates and give kudos to awesome technicians.
  * @param {string} notes - Notes for the technician to provide relevant data/help/suggestions/clarifications to other technicians.
  * @param {number} number_of_targets - The number of users targeted in this campagin.
  * @param {number} number_of_clicks - The number of unique clicks in this campaign. We focus on throughput for the template itself and its ability to generate interaction.
  */
  constructor(template_id, ich_id, spam_filter_id, whitelisted, stars, notes, number_of_targets, number_of_clicks){
    let new_scorecard = Scorecard.AddScorecard(template_id, ich_id, spam_filter_id, whitelisted, stars, notes, number_of_targets, number_of_clicks){
    return new_scorecard
  }
  /**
  * @param {number} template_id - The ID of the template the phishing email was build from.
  * @param {number} ich_id - The ID of the user who is submitting the Scorecard. This is infered from the user's API key.
  * @param {(number|string)} spam_filter_id - The spam filter that the technician sent the phishing email to/through. If an number, then it is the ID of an existing SpamFilter object. If a string, we add a new SpamFilter to track.
  * @param {boolean} whitelisted - Did the technician need the client to whitelist this email phishing template? 0 for NO, 1 for YES.
  * @param {number} stars - How did the technician rate the scenario on a scale of 1 to 5? Helps to rank templates and give kudos to awesome technicians.
  * @param {string} notes - Notes for the technician to provide relevant data/help/suggestions/clarifications to other technicians.
  * @param {number} number_of_targets - The number of users targeted in this campagin.
  * @param {number} number_of_clicks - The number of unique clicks in this campaign. We focus on throughput for the template itself and its ability to generate interaction.
  */
  static AddScorecard(template_id, ich_id, spam_filter_id, whitelisted, stars, notes, number_of_targets, number_of_clicks){
    let add_template = db.prepare(`
      INSERT INTO templates VALUES(
        $scorecard_id,
        $template_id,
        $ich_id,
        $spam_filter_id,
        $created_at,
        $whitelisted,
        $stars,
        $notes,
        $number_of_targets,
        $number_of_clicks
      )
    `)
    return add_template.run({
      "scorecard_id": null,
      "template_id": template_id,
      "ich_id": ich_id,
      "spam_filter_id": spam_filter_id,
      "created_at": Date.now(),
      "whitelisted": whitelisted,
      "stars": stars,
      "notes": notes,
      "number_of_targets": number_of_targets,
      "number_of_clicks": number_of_clicks
    })
  }
  /**
  * @param {number} template_id - The ID of the Template object we are getting Scorecard object for.
  */
  static GetScorecards(template_id){
    let get_scorecards = db.prepare(`
      SELECT * from scorecards WHERE template_id = $template_id
    `)
    return get_scorecards.all({
      "template_id": template_id
    })
  }
  /**
  * @param {number} scorecard_id - The ID of the Scorecard object to delete.
  */
  static DeleteScorecard(scorecard_id){
  }
}

/** Class representing an approved technician. Each API key is hard coded in the config file. */
class Ichthyologist{
  /**
  * @param {string} api_key - The API key of the technician. This route is used to authorize actions and apply ich_id attributes to other Templates, Scorecards, etc.
  */
  static GetIchthyologistIDByAPIKey(api_key){
    let get_ich = db.prepare(`
      SELECT ich_id FROM ichthyologists WHERE api_key = $api_key
    `)
    return get_ich.get({
      "api_key": api_key
    })
  }
  /**
  * @param {number} ich_id - The ID of the user we want to get a handle for.
  */
  static GetIchthyologistHandleByID(ich_id){
    let get_ich = db.prepare(`
      SELECT handle FROM ichthyologists WHERE ich_id = $ich_id
    `)
    return get_ich.get({
      "ich_id": ich_id
    })
  }
}

/** Class representing a spam filter product that we want to track metrics for. */
class SpamFilter{
  /**
  * @param {number} ich_id - The ID of the user who added this SpamFilter object.
  * @param {string} prouct_name - The name of the spam filter product. We keep these as SpamFilter objects in the tool to standardize their references and run metrics on the individual prouct.
  */
  constructor(ich_id, product_name){
    let new_spam_filter = SpamFilter.AddSpamFilter(ich_id, product_name)
    return new_spam_filter
  }
  /**
  * @param {string} prouct_name - The name of the spam filter product. We keep these as SpamFilter objects in the tool to standardize their references and run metrics on the individual prouct.
  * @param {number} ich_id - The ID of the user who added this SpamFilter object.
  */
  static AddSpamFilter(ich_id, product_name){
    let add_spam_filter = db.prepare(`
      INSERT INTO spamfilters VALUES(
        $spam_filter_id,
        $ich_id,
        $created_at,
        $product_name
      )
    `)
    return add_spam_filter.run({
      "spam_filter_id": null,
      "ich_id": ich_id,
      "created_at": Date.now(),
      "product_name": product_name
    })
  }
  static ListSpamFilters(){
    list_filters = db.prepare(`SELECT product_name FROM spamfilters`).pluck
    return list_filters.all()
  }
}

/** Class representing an image of a phishing template. We seperate them to limit data transfers when searching Template objects. */
class Specimen{
  /**
  * @param {number} ich_id - The ID of the technician that added this specimen by publishing a template.
  * @param {string} image - The base64 encoded image of the email Template object as generated by Phishmonger's preview feature.
  */
  constructor(template_id, ich_id, image){
    let new_specimen = Specimen.AddSpecimen(template_id, ich_id, image)
    return new_specimen
  }
  /**
  * @param {string} image - The base64 encoded image of the email Template object as generated by Phishmonger's preview feature.
  */
  static AddSpecimen(template_id, ich_id, image){
    let add_specimen = db.prepare(`
      INSERT INTO specimens VALUES(
        $specimen_id,
        $template_id,
        $ich_id,
        $created_at,
        $image
      )
    `)
    return add_specimen.run({
      "specimen_id": null,
      "template_id": template_id,
      "ich_id": ich_id,
      "created_at": Date.now(),
      "image": image
    })
  }
  /**
  * @param {number} specimen_id - The ID of the Specimen object to get.
  */
  static GetSpecimen(specimen_id){
    let get_specimen = db.prepare(`
      SELECT * FROM specimens WHERE specimen_id = $specimen_id
    `)
    return get_specimen.get({
      "specimen_id": specimen_id
    })
  }
  /**
  * @param {number} specimen_id - The ID of the Specimen object we are updating.
  * @param {string} image - The base64 encoded image of the email Template object as generated by Phishmonger's preview feature.
  */
  static UpdateSpecimen(specimen_id, image){
  }
  /**
  * @param {number} specimen_id - The ID of the Specimen object to delete.
  */
  static DeleteSpecimen(specimen_id){
  }
}

module.exports = {
  Template: Template,
  Scorecard: Scorecard, 
  Ichthyologist: Ichthyologist, 
  SpamFilter: SpamFilter, 
  Specimen: Specimen 
}
